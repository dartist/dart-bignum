        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>int64 class / fixnum Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="fixnum" data-type="int64">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../fixnum.html">fixnum</a> &rsaquo; <a href="../fixnum/int64.html">int64</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>int64</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>An immutable 64-bit signed integer, in the range <code>-2^63, 2^63 - 1</code>.
Arithmetic operations may overflow in order to maintain this range.</p>
<pre class="source">
class int64 implements intx {

 // A 64-bit integer is represented internally as three non-negative
 // integers, storing the 22 low, 22 middle, and 20 high bits of the
 // 64-bit value.  _l (low) and _m (middle) are in the range
 // [0, 2^22 - 1] and _h (high) is in the range [0, 2^20 - 1].
 int _l, _m, _h;

 // Note: instances of int64 are immutable outside of this library,
 // therefore we may return a reference to an existing instance.
 // We take care to perform mutation only on internally-generated
 // instances before they are exposed to external code.

 // Note: several functions require _BITS == 22 -- do not change this value.
 static final int _BITS = 22;
 static final int _BITS01 = 44; // 2 * _BITS
 static final int _BITS2 = 20; // 64 - _BITS01
 static final int _MASK = 4194303; // (1 &lt;&lt; _BITS) - 1
 static final int _MASK_2 = 1048575; // (1 &lt;&lt; _BITS2) - 1
 static final int _SIGN_BIT = 19; // _BITS2 - 1
 static final int _SIGN_BIT_VALUE = 524288; // 1 &lt;&lt; _SIGN_BIT

 // Cached constants
 static int64 _MAX_VALUE;
 static int64 _MIN_VALUE;
 static int64 _ZERO;
 static int64 _ONE;
 static int64 _TWO;

 // Precompute the radix strings for MIN_VALUE to avoid the problem
 // of overflow of -MIN_VALUE.
 static List&lt;String&gt; _minValues = const &lt;String&gt;[
     null, null,
     "-1000000000000000000000000000000000000000000000000000000000000000", // 2
     "-2021110011022210012102010021220101220222", // base 3
     "-20000000000000000000000000000000", // base 4
     "-1104332401304422434310311213", // base 5
     "-1540241003031030222122212", // base 6
     "-22341010611245052052301", // base 7
     "-1000000000000000000000", // base 8
     "-67404283172107811828", // base 9
     "-9223372036854775808", // base 10
     "-1728002635214590698", // base 11
     "-41A792678515120368", // base 12
     "-10B269549075433C38", // base 13
     "-4340724C6C71DC7A8", // base 14
     "-160E2AD3246366808", // base 15
     "-8000000000000000" // base 16
 ];

 // The remainder of the last divide operation.
 static int64 _remainder;

 /**
  * The maximum positive value attainable by an [int64], namely
  * 9,223,372,036,854,775,807.
  */
 static int64 get MAX_VALUE {
   if (_MAX_VALUE == null) {
     _MAX_VALUE = new int64._bits(_MASK, _MASK, _MASK_2 &gt;&gt; 1);
   }
   return _MAX_VALUE;
 }

 /**
  * The minimum positive value attainable by an [int64], namely
  * -9,223,372,036,854,775,808.
  */
 static int64 get MIN_VALUE {
   if (_MIN_VALUE == null) {
     _MIN_VALUE = new int64._bits(0, 0, _SIGN_BIT_VALUE);
   }
   return _MIN_VALUE;
 }

 /**
  * An [int64] constant equal to 0.
  */
 static int64 get ZERO {
   if (_ZERO == null) {
     _ZERO = new int64();
   }
   return _ZERO;
 }

 /**
  * An [int64] constant equal to 1.
  */
 static int64 get ONE {
   if (_ONE == null) {
     _ONE = new int64._bits(1, 0, 0);
   }
   return _ONE;
 }

 /**
  * An [int64] constant equal to 2.
  */
 static int64 get TWO {
   if (_TWO == null) {
     _TWO = new int64._bits(2, 0, 0);
   }
   return _TWO;
 }

 /**
  * Parses a [String] in a given [radix] between 2 and 16 and returns an
  * [int64].
  */
 // TODO(rice) - make this faster by converting several digits at once.
 static int64 parseRadix(String s, int radix) {
   if ((radix &lt;= 1) || (radix &gt; 16)) {
     throw "Bad radix: $radix";
   }
   int64 x = ZERO;
   int i = 0;
   bool negative = false;
   if (s[0] == '-') {
     negative = true;
     i++;
   }
   for (; i &lt; s.length; i++) {
     int c = s.codeUnitAt(i);
     int digit = int32._decodeHex(c);
     if (digit &lt; 0 || digit &gt;= radix) {
       throw new Exception("Non-radix char code: $c");
     }
     x = (x * radix) + digit;
   }
   return negative ? -x : x;
 }

 /**
  * Parses a decimal [String] and returns an [int64].
  */
 static int64 parseInt(String s) =&gt; parseRadix(s, 10);

 /**
  * Parses a hexadecimal [String] and returns an [int64].
  */
 static int64 parseHex(String s) =&gt; parseRadix(s, 16);

 //
 // Public constructors
 //

 /**
  * Constructs an [int64] equal to 0.
  */
 int64() : _l = 0, _m = 0, _h = 0;

 /**
  * Constructs an [int64] with a given [int] value.
  */
 int64.fromInt(int value) {
   bool negative = false;
   if (value &lt; 0) {
     negative = true;
     value = -value - 1;
   }
   if (_haveBigInts) {
     _l = value &amp; _MASK;
     _m = (value &gt;&gt; _BITS) &amp; _MASK;
     _h = (value &gt;&gt; _BITS01) &amp; _MASK_2;
   } else {
     // Avoid using bitwise operations that coerce their input to 32 bits.
     _h = value ~/ 17592186044416; // 2^44
     value -= _h * 17592186044416;
     _m = value ~/ 4194304; // 2^22
     value -= _m * 4194304;
     _l = value;
   }

   if (negative) {
     _l = ~_l &amp; _MASK;
     _m = ~_m &amp; _MASK;
     _h = ~_h &amp; _MASK_2;
   }
 }

 factory int64.fromBytes(List&lt;int&gt; bytes) {
   int top = bytes[7] &amp; 0xff;
   top &lt;&lt;= 8;
   top |= bytes[6] &amp; 0xff;
   top &lt;&lt;= 8;
   top |= bytes[5] &amp; 0xff;
   top &lt;&lt;= 8;
   top |= bytes[4] &amp; 0xff;

   int bottom = bytes[3] &amp; 0xff;
   bottom &lt;&lt;= 8;
   bottom |= bytes[2] &amp; 0xff;
   bottom &lt;&lt;= 8;
   bottom |= bytes[1] &amp; 0xff;
   bottom &lt;&lt;= 8;
   bottom |= bytes[0] &amp; 0xff;

   return new int64.fromInts(top, bottom);
 }

 factory int64.fromBytesBigEndian(List&lt;int&gt; bytes) {
   int top = bytes[0] &amp; 0xff;
   top &lt;&lt;= 8;
   top |= bytes[1] &amp; 0xff;
   top &lt;&lt;= 8;
   top |= bytes[2] &amp; 0xff;
   top &lt;&lt;= 8;
   top |= bytes[3] &amp; 0xff;

   int bottom = bytes[4] &amp; 0xff;
   bottom &lt;&lt;= 8;
   bottom |= bytes[5] &amp; 0xff;
   bottom &lt;&lt;= 8;
   bottom |= bytes[6] &amp; 0xff;
   bottom &lt;&lt;= 8;
   bottom |= bytes[7] &amp; 0xff;

   return new int64.fromInts(top, bottom);
}

 /**
  * Constructs an [int64] from a pair of 32-bit integers having the value
  * [:((top &amp; 0xffffffff) &lt;&lt; 32) | (bottom &amp; 0xffffffff):].
  */
 int64.fromInts(int top, int bottom) {
   top &amp;= 0xffffffff;
   bottom &amp;= 0xffffffff;
   _l = bottom &amp; _MASK;
   _m = ((top &amp; 0xfff) &lt;&lt; 10) | ((bottom &gt;&gt; _BITS) &amp; 0x3ff);
   _h = (top &gt;&gt; 12) &amp; _MASK_2;
 }

 int64 _promote(other) {
   if (other == null) {
     throw new ArgumentError("null");
   } else if (other is intx) {
     other = other.toInt64();
   } else if (other is int) {
     other = new int64.fromInt(other);
   }
   if (other is !int64) {
     throw new Exception("Can't promote $other to int64");
   }
   return other;
 }

 int64 operator +(other) {
   int64 o = _promote(other);
   int sum0 = _l + o._l;
   int sum1 = _m + o._m + _shiftRight(sum0, _BITS);
   int sum2 = _h + o._h + _shiftRight(sum1, _BITS);

   int64 result = new int64._bits(sum0 &amp; _MASK, sum1 &amp; _MASK, sum2 &amp; _MASK_2);
   return result;
 }

 int64 operator -(other) {
   int64 o = _promote(other);

   int sum0 = _l - o._l;
   int sum1 = _m - o._m + _shiftRight(sum0, _BITS);
   int sum2 = _h - o._h + _shiftRight(sum1, _BITS);

   int64 result = new int64._bits(sum0 &amp; _MASK, sum1 &amp; _MASK, sum2 &amp; _MASK_2);
   return result;
 }

 int64 operator -() {
   // Like 0 - this.
   int sum0 = -_l;
   int sum1 = -_m + _shiftRight(sum0, _BITS);
   int sum2 = -_h + _shiftRight(sum1, _BITS);

   return new int64._bits(sum0 &amp; _MASK, sum1 &amp; _MASK, sum2 &amp; _MASK_2);
 }

 int64 operator *(other) {
   int64 o = _promote(other);
   // Grab 13-bit chunks.
   int a0 = _l &amp; 0x1fff;
   int a1 = (_l &gt;&gt; 13) | ((_m &amp; 0xf) &lt;&lt; 9);
   int a2 = (_m &gt;&gt; 4) &amp; 0x1fff;
   int a3 = (_m &gt;&gt; 17) | ((_h &amp; 0xff) &lt;&lt; 5);
   int a4 = (_h &amp; 0xfff00) &gt;&gt; 8;

   int b0 = o._l &amp; 0x1fff;
   int b1 = (o._l &gt;&gt; 13) | ((o._m &amp; 0xf) &lt;&lt; 9);
   int b2 = (o._m &gt;&gt; 4) &amp; 0x1fff;
   int b3 = (o._m &gt;&gt; 17) | ((o._h &amp; 0xff) &lt;&lt; 5);
   int b4 = (o._h &amp; 0xfff00) &gt;&gt; 8;

   // Compute partial products.
   // Optimization: if b is small, avoid multiplying by parts that are 0.
   int p0 = a0 * b0; // &lt;&lt; 0
   int p1 = a1 * b0; // &lt;&lt; 13
   int p2 = a2 * b0; // &lt;&lt; 26
   int p3 = a3 * b0; // &lt;&lt; 39
   int p4 = a4 * b0; // &lt;&lt; 52

   if (b1 != 0) {
     p1 += a0 * b1;
     p2 += a1 * b1;
     p3 += a2 * b1;
     p4 += a3 * b1;
   }
   if (b2 != 0) {
     p2 += a0 * b2;
     p3 += a1 * b2;
     p4 += a2 * b2;
   }
   if (b3 != 0) {
     p3 += a0 * b3;
     p4 += a1 * b3;
   }
   if (b4 != 0) {
     p4 += a0 * b4;
   }

   // Accumulate into 22-bit chunks:
   // .........................................c10|...................c00|
   // |....................|..................xxxx|xxxxxxxxxxxxxxxxxxxxxx| p0
   // |....................|......................|......................|
   // |....................|...................c11|......c01.............|
   // |....................|....xxxxxxxxxxxxxxxxxx|xxxxxxxxx.............| p1
   // |....................|......................|......................|
   // |.................c22|...............c12....|......................|
   // |..........xxxxxxxxxx|xxxxxxxxxxxxxxxxxx....|......................| p2
   // |....................|......................|......................|
   // |.................c23|..c13.................|......................|
   // |xxxxxxxxxxxxxxxxxxxx|xxxxx.................|......................| p3
   // |....................|......................|......................|
   // |.........c24........|......................|......................|
   // |xxxxxxxxxxxx........|......................|......................| p4

   int c00 = p0 &amp; 0x3fffff;
   int c01 = (p1 &amp; 0x1ff) &lt;&lt; 13;
   int c0 = c00 + c01;

   int c10 = p0 &gt;&gt; 22;
   int c11 = p1 &gt;&gt; 9;
   int c12 = (p2 &amp; 0x3ffff) &lt;&lt; 4;
   int c13 = (p3 &amp; 0x1f) &lt;&lt; 17;
   int c1 = c10 + c11 + c12 + c13;

   int c22 = p2 &gt;&gt; 18;
   int c23 = p3 &gt;&gt; 5;
   int c24 = (p4 &amp; 0xfff) &lt;&lt; 8;
   int c2 = c22 + c23 + c24;

   // Propagate high bits from c0 -&gt; c1, c1 -&gt; c2.
   c1 += c0 &gt;&gt; _BITS;
   c0 &amp;= _MASK;
   c2 += c1 &gt;&gt; _BITS;
   c1 &amp;= _MASK;
   c2 &amp;= _MASK_2;

   return new int64._bits(c0, c1, c2);
 }

 int64 operator %(other) {
   if (other.isZero()) {
     throw new IntegerDivisionByZeroException();
   }
   if (this.isZero()) {
     return ZERO;
   }
   int64 o = _promote(other).abs();
   _divMod(this, o, true);
   return _remainder &lt; 0 ? (_remainder + o) : _remainder;
 }

 int64 operator ~/(other) =&gt; _divMod(this, _promote(other), false);

 // int64 remainder(other) =&gt; this - (this ~/ other) * other;
 int64 remainder(other) {
   if (other.isZero()) {
     throw new IntegerDivisionByZeroException();
   }
   int64 o = _promote(other).abs();
   _divMod(this, o, true);
   return _remainder;
 }

 int64 operator &amp;(other) {
   int64 o = _promote(other);
   int a0 = _l &amp; o._l;
   int a1 = _m &amp; o._m;
   int a2 = _h &amp; o._h;
   return new int64._bits(a0, a1, a2);
 }

 int64 operator |(other) {
   int64 o = _promote(other);
   int a0 = _l | o._l;
   int a1 = _m | o._m;
   int a2 = _h | o._h;
   return new int64._bits(a0, a1, a2);
 }

 int64 operator ^(other) {
   int64 o = _promote(other);
   int a0 = _l ^ o._l;
   int a1 = _m ^ o._m;
   int a2 = _h ^ o._h;
   return new int64._bits(a0, a1, a2);
 }

 int64 operator ~() {
   var result = new int64._bits((~_l) &amp; _MASK, (~_m) &amp; _MASK, (~_h) &amp; _MASK_2);
   return result;
 }

 int64 operator &lt;&lt;(int n) {
   if (n &lt; 0) {
     throw new ArgumentError("$n");
   }
   n &amp;= 63;

   int res0, res1, res2;
   if (n &lt; _BITS) {
     res0 = _l &lt;&lt; n;
     res1 = (_m &lt;&lt; n) | (_l &gt;&gt; (_BITS - n));
     res2 = (_h &lt;&lt; n) | (_m &gt;&gt; (_BITS - n));
   } else if (n &lt; _BITS01) {
     res0 = 0;
     res1 = _l &lt;&lt; (n - _BITS);
     res2 = (_m &lt;&lt; (n - _BITS)) | (_l &gt;&gt; (_BITS01 - n));
   } else {
     res0 = 0;
     res1 = 0;
     res2 = _l &lt;&lt; (n - _BITS01);
   }

   return new int64._bits(res0 &amp; _MASK, res1 &amp; _MASK, res2 &amp; _MASK_2);
 }

 int64 operator &gt;&gt;(int n) {
   if (n &lt; 0) {
     throw new ArgumentError("$n");
   }
   n &amp;= 63;

   int res0, res1, res2;

   // Sign extend h(a).
   int a2 = _h;
   bool negative = (a2 &amp; _SIGN_BIT_VALUE) != 0;
   if (negative) {
     a2 += 0x3 &lt;&lt; _BITS2; // add extra one bits on the left
   }

   if (n &lt; _BITS) {
     res2 = _shiftRight(a2, n);
     if (negative) {
       res2 |= _MASK_2 &amp; ~(_MASK_2 &gt;&gt; n);
     }
     res1 = _shiftRight(_m, n) | (a2 &lt;&lt; (_BITS - n));
     res0 = _shiftRight(_l, n) | (_m &lt;&lt; (_BITS - n));
   } else if (n &lt; _BITS01) {
     res2 = negative ? _MASK_2 : 0;
     res1 = _shiftRight(a2, n - _BITS);
     if (negative) {
       res1 |= _MASK &amp; ~(_MASK &gt;&gt; (n - _BITS));
     }
     res0 = _shiftRight(_m, n - _BITS) | (a2 &lt;&lt; (_BITS01 - n));
   } else {
     res2 = negative ? _MASK_2 : 0;
     res1 = negative ? _MASK : 0;
     res0 = _shiftRight(a2, n - _BITS01);
     if (negative) {
       res0 |= _MASK &amp; ~(_MASK &gt;&gt; (n - _BITS01));
     }
   }

   return new int64._bits(res0 &amp; _MASK, res1 &amp; _MASK, res2 &amp; _MASK_2);
 }

 int64 shiftRightUnsigned(int n) {
   if (n &lt; 0) {
     throw new ArgumentError("$n");
   }
   n &amp;= 63;

   int res0, res1, res2;
   int a2 = _h &amp; _MASK_2; // Ensure a2 is positive.
   if (n &lt; _BITS) {
     res2 = a2 &gt;&gt; n;
     res1 = (_m &gt;&gt; n) | (a2 &lt;&lt; (_BITS - n));
     res0 = (_l &gt;&gt; n) | (_m &lt;&lt; (_BITS - n));
   } else if (n &lt; _BITS01) {
     res2 = 0;
     res1 = a2 &gt;&gt; (n - _BITS);
     res0 = (_m &gt;&gt; (n - _BITS)) | (_h &lt;&lt; (_BITS01 - n));
   } else {
     res2 = 0;
     res1 = 0;
     res0 = a2 &gt;&gt; (n - _BITS01);
   }

   return new int64._bits(res0 &amp; _MASK, res1 &amp; _MASK, res2 &amp; _MASK_2);
 }

 /**
  * Returns [true] if this [int64] has the same numeric value as the
  * given object.  The argument may be an [int] or an [intx].
  */
 bool operator ==(other) {
   if (other == null) {
     return false;
   }
   int64 o = _promote(other);
   return _l == o._l &amp;&amp; _m == o._m &amp;&amp; _h == o._h;
 }

 int compareTo(Comparable other) {
   int64 o = _promote(other);
   int signa = _h &gt;&gt; (_BITS2 - 1);
   int signb = o._h &gt;&gt; (_BITS2 - 1);
   if (signa != signb) {
     return signa == 0 ? 1 : -1;
   }
   if (_h &gt; o._h) {
     return 1;
   } else if (_h &lt; o._h) {
     return -1;
   }
   if (_m &gt; o._m) {
     return 1;
   } else if (_m &lt; o._m) {
     return -1;
   }
   if (_l &gt; o._l) {
     return 1;
   } else if (_l &lt; o._l) {
     return -1;
   }
   return 0;
 }

 bool operator &lt;(other) {
   return this.compareTo(other) &lt; 0;
 }

 bool operator &lt;=(other) {
   return this.compareTo(other) &lt;= 0;
 }

 bool operator &gt;(other) {
   return this.compareTo(other) &gt; 0;
 }

 bool operator &gt;=(other) {
   return this.compareTo(other) &gt;= 0;
 }

 bool isEven() =&gt; (_l &amp; 0x1) == 0;
 bool isMaxValue() =&gt; (_h == _MASK_2 &gt;&gt; 1) &amp;&amp; _m == _MASK &amp;&amp; _l == _MASK;
 bool isMinValue() =&gt; _h == _SIGN_BIT_VALUE &amp;&amp; _m == 0 &amp;&amp; _l == 0;
 bool isNegative() =&gt; (_h &gt;&gt; (_BITS2 - 1)) != 0;
 bool isOdd() =&gt; (_l &amp; 0x1) == 1;
 bool isZero() =&gt; _h == 0 &amp;&amp; _m == 0 &amp;&amp; _l == 0;

 /**
  * Returns a hash code based on all the bits of this [int64].
  */
 int get hashCode {
   int bottom = ((_m &amp; 0x3ff) &lt;&lt; _BITS) | _l;
   int top = (_h &lt;&lt; 12) | ((_m &gt;&gt; 10) &amp; 0xfff);
   return bottom ^ top;
 }

 int64 abs() {
   return this &lt; 0 ? -this : this;
 }

 /**
  * Returns the number of leading zeros in this [int64] as an [int]
  * between 0 and 64.
  */
 int numberOfLeadingZeros() {
   int b2 = int32._numberOfLeadingZeros(_h);
   if (b2 == 32) {
     int b1 = int32._numberOfLeadingZeros(_m);
     if (b1 == 32) {
       return int32._numberOfLeadingZeros(_l) + 32;
     } else {
       return b1 + _BITS2 - (32 - _BITS);
     }
   } else {
     return b2 - (32 - _BITS2);
   }
 }

 /**
  * Returns the number of trailing zeros in this [int64] as an [int]
  * between 0 and 64.
  */
 int numberOfTrailingZeros() {
   int zeros = int32._numberOfTrailingZeros(_l);
   if (zeros &lt; 32) {
     return zeros;
   }

   zeros = int32._numberOfTrailingZeros(_m);
   if (zeros &lt; 32) {
     return _BITS + zeros;
   }

   zeros = int32._numberOfTrailingZeros(_h);
   if (zeros &lt; 32) {
     return _BITS01 + zeros;
   }
   // All zeros
   return 64;
 }

 List&lt;int&gt; toBytes() {
   List&lt;int&gt; result = new List&lt;int&gt;.fixedLength(8);
   result[0] = _l &amp; 0xff;
   result[1] = (_l &gt;&gt; 8) &amp; 0xff;
   result[2] = ((_m &lt;&lt; 6) &amp; 0xfc) | ((_l &gt;&gt; 16) &amp; 0x3f);
   result[3] = (_m &gt;&gt; 2) &amp; 0xff;
   result[4] = (_m &gt;&gt; 10) &amp; 0xff;
   result[5] = ((_h &lt;&lt; 4) &amp; 0xf0) | ((_m &gt;&gt; 18) &amp; 0xf);
   result[6] = (_h &gt;&gt; 4) &amp; 0xff;
   result[7] = (_h &gt;&gt; 12) &amp; 0xff;
   return result;
 }

 int toInt() {
   int l = _l;
   int m = _m;
   int h = _h;
   bool negative = false;
   if ((_h &amp; _SIGN_BIT_VALUE) != 0) {
     l = ~_l &amp; _MASK;
     m = ~_m &amp; _MASK;
     h = ~_h &amp; _MASK_2;
     negative = true;
   }

   int result;
   if (_haveBigInts) {
     result = (h &lt;&lt; _BITS01) | (m &lt;&lt; _BITS) | l;
   } else {
     result = (h * 17592186044416) + (m * 4194304) + l;
   }
   return negative ? -result - 1 : result;
 }

 /**
  * Returns an [int32] containing the low 32 bits of this [int64].
  */
 int32 toInt32() {
   return new int32.fromInt(((_m &amp; 0x3ff) &lt;&lt; _BITS) | _l);
 }

 /**
  * Returns [this].
  */
 int64 toInt64() =&gt; this;

 /**
  * Returns the value of this [int64] as a decimal [String].
  */
 // TODO(rice) - Make this faster by converting several digits at once.
 String toString() {
   int64 a = this;
   if (a.isZero()) {
     return "0";
   }
   if (a.isMinValue()) {
     return "-9223372036854775808";
   }

   String result = "";
   bool negative = false;
   if (a.isNegative()) {
     negative = true;
     a = -a;
   }

   int64 ten = new int64._bits(10, 0, 0);
   while (!a.isZero()) {
     a = _divMod(a, ten, true);
     result = "${_remainder._l}$result";
   }
   if (negative) {
     result = "-$result";
   }
   return result;
 }

 // TODO(rice) - Make this faster by avoiding arithmetic.
 String toHexString() {
   int64 x = new int64._copy(this);
   if (isZero()) {
     return "0";
   }
   String hexStr = "";
   int64 digit_f = new int64.fromInt(0xf);
   while (!x.isZero()) {
     int digit = x._l &amp; 0xf;
     hexStr = "${_hexDigit(digit)}$hexStr";
     x = x.shiftRightUnsigned(4);
   }
   return hexStr;
 }

 String toRadixString(int radix) {
   if ((radix &lt;= 1) || (radix &gt; 16)) {
     throw "Bad radix: $radix";
   }
   int64 a = this;
   if (a.isZero()) {
     return "0";
   }
   if (a.isMinValue()) {
     return _minValues[radix];
   }

   String result = "";
   bool negative = false;
   if (a.isNegative()) {
     negative = true;
     a = -a;
   }

   int64 r = new int64._bits(radix, 0, 0);
   while (!a.isZero()) {
     a = _divMod(a, r, true);
     result = "${_hexDigit(_remainder._l)}$result";
   }
   return negative ? "-$result" : result;
 }

 String toDebugString() {
   return "int64[_l=$_l, _m=$_m, _h=$_h]";
 }

 /**
  * Constructs an [int64] with a given bitwise representation.  No validation
  * is performed.
  */
 int64._bits(int this._l, int this._m, int this._h);

 /**
  * Constructs an [int64] with the same value as an existing [int64].
  */
 int64._copy(int64 other) {
   _l = other._l;
   _m = other._m;
   _h = other._h;
 }

 // Determine whether the platform supports ints greater than 2^53
 // without loss of precision.
 static bool _haveBigIntsCached = null;

 static bool get _haveBigInts {
   if (_haveBigIntsCached == null) {
     var x = 9007199254740992;
     // Defeat compile-time constant folding.
     if (2 + 2 != 4) {
       x = 0;
     }
     var y = x + 1;
     var same = y == x;
     _haveBigIntsCached = !same;
   }
   return _haveBigIntsCached;
 }

 String _hexDigit(int digit) =&gt; "0123456789ABCDEF"[digit];

 // Implementation of '~/' and '%'.

 // Note: mutates [this].
 void _negate() {
   int neg0 = (~_l + 1) &amp; _MASK;
   int neg1 = (~_m + (neg0 == 0 ? 1 : 0)) &amp; _MASK;
   int neg2 = (~_h + ((neg0 == 0 &amp;&amp; neg1 == 0) ? 1 : 0)) &amp; _MASK_2;

   _l = neg0;
   _m = neg1;
   _h = neg2;
 }

 // Note: mutates [this].
 void _setBit(int bit) {
   if (bit &lt; _BITS) {
     _l |= 0x1 &lt;&lt; bit;
   } else if (bit &lt; _BITS01) {
     _m |= 0x1 &lt;&lt; (bit - _BITS);
   } else {
     _h |= 0x1 &lt;&lt; (bit - _BITS01);
   }
 }

 // Note: mutates [this].
 void _toShru1() {
   int a2 = _h;
   int a1 = _m;
   int a0 = _l;

   _h = a2 &gt;&gt; 1;
   _m = (a1 &gt;&gt; 1) | ((a2 &amp; 0x1) &lt;&lt; (_BITS - 1));
   _l = (a0 &gt;&gt; 1) | ((a1 &amp; 0x1) &lt;&lt; (_BITS - 1));
 }

 // Work around dart2js bugs with negative arguments to '&gt;&gt;' operator.
 static int _shiftRight(int x, int n) {
   if (x &gt;= 0) {
     return x &gt;&gt; n;
   } else {
     int shifted = x &gt;&gt; n;
     if (shifted &gt;= 0x80000000) {
       shifted -= 4294967296;
     }
     return shifted;
   }
 }

 /**
  * Attempt to subtract b from a if a &gt;= b:
  *
  * if (a &gt;= b) {
  *   a -= b;
  *   return true;
  * } else {
  *   return false;
  * }
  */
 // Note: mutates [a].
 static bool _trialSubtract(int64 a, int64 b) {
   // Early exit.
   int sum2 = a._h - b._h;
   if (sum2 &lt; 0) {
     return false;
   }

   int sum0 = a._l - b._l;
   int sum1 = a._m - b._m + _shiftRight(sum0, _BITS);
   sum2 += _shiftRight(sum1, _BITS);

   if (sum2 &lt; 0) {
     return false;
   }

   a._l = sum0 &amp; _MASK;
   a._m = sum1 &amp; _MASK;
   a._h = sum2 &amp; _MASK_2;

   return true;
 }

 // Note: mutates [a] via _trialSubtract.
 static int64 _divModHelper(int64 a, int64 b,
     bool negative, bool aIsNegative, bool aIsMinValue,
     bool computeRemainder) {
   // Align the leading one bits of a and b by shifting b left.
   int shift = b.numberOfLeadingZeros() - a.numberOfLeadingZeros();
   int64 bshift = b &lt;&lt; shift;

   // Quotient must be a new instance since we mutate it.
   int64 quotient = new int64();
   while (shift &gt;= 0) {
     bool gte = _trialSubtract(a, bshift);
     if (gte) {
       quotient._setBit(shift);
       if (a.isZero()) {
         break;
       }
     }

     bshift._toShru1();
     shift--;
   }

   if (negative) {
     quotient._negate();
   }

   if (computeRemainder) {
     if (aIsNegative) {
       _remainder = -a;
       if (aIsMinValue) {
         _remainder = _remainder - ONE;
       }
     } else {
       _remainder = a;
     }
   }

   return quotient;
 }

 int64 _divModByMinValue(bool computeRemainder) {
   // MIN_VALUE / MIN_VALUE == 1, remainder = 0
   // (x != MIN_VALUE) / MIN_VALUE == 0, remainder == x
   if (isMinValue()) {
     if (computeRemainder) {
       _remainder = ZERO;
     }
     return ONE;
   }
   if (computeRemainder) {
     _remainder = this;
   }
   return ZERO;
 }

 /**
  * this &amp;= ((1L &lt;&lt; bits) - 1)
  */
 // Note: mutates [this].
 int64 _maskRight(int bits) {
   int b0, b1, b2;
   if (bits &lt;= _BITS) {
     b0 = _l &amp; ((1 &lt;&lt; bits) - 1);
     b1 = b2 = 0;
   } else if (bits &lt;= _BITS01) {
     b0 = _l;
     b1 = _m &amp; ((1 &lt;&lt; (bits - _BITS)) - 1);
     b2 = 0;
   } else {
     b0 = _l;
     b1 = _m;
     b2 = _h &amp; ((1 &lt;&lt; (bits - _BITS01)) - 1);
   }

   _l = b0;
   _m = b1;
   _h = b2;
 }

 int64 _divModByShift(int64 a, int bpower, bool negative, bool aIsCopy,
     bool aIsNegative, bool computeRemainder) {
   int64 c = a &gt;&gt; bpower;
   if (negative) {
     c._negate();
   }

   if (computeRemainder) {
     if (!aIsCopy) {
       a = new int64._copy(a);
     }
     a._maskRight(bpower);
     if (aIsNegative) {
       a._negate();
     }
     _remainder = a;
   }
   return c;
 }

 /**
  * Return the exact log base 2 of this, or -1 if this is not a power of two.
  */
 int _powerOfTwo() {
   // Power of two or 0.
   int l = _l;
   if ((l &amp; (l - 1)) != 0) {
     return -1;
   }
   int m = _m;
   if ((m &amp; (m - 1)) != 0) {
     return -1;
   }
   int h = _h;
   if ((h &amp; (h - 1)) != 0) {
     return -1;
   }
   if (h == 0 &amp;&amp; m == 0 &amp;&amp; l == 0) {
     return -1;
   }
   if (h == 0 &amp;&amp; m == 0 &amp;&amp; l != 0) {
     return int32._numberOfTrailingZeros(l);
   }
   if (h == 0 &amp;&amp; m != 0 &amp;&amp; l == 0) {
     return int32._numberOfTrailingZeros(m) + _BITS;
   }
   if (h != 0 &amp;&amp; m == 0 &amp;&amp; l == 0) {
     return int32._numberOfTrailingZeros(h) + _BITS01;
   }

   return -1;
 }

 int64 _divMod(int64 a, int64 b, bool computeRemainder) {
   if (b.isZero()) {
     throw new IntegerDivisionByZeroException();
   }
   if (a.isZero()) {
     if (computeRemainder) {
       _remainder = ZERO;
     }
     return ZERO;
   }
   // MIN_VALUE / MIN_VALUE = 1, anything other a / MIN_VALUE is 0.
   if (b.isMinValue()) {
     return a._divModByMinValue(computeRemainder);
   }
   // Normalize b to abs(b), keeping track of the parity in 'negative'.
   // We can do this because we have already ensured that b != MIN_VALUE.
   bool negative = false;
   if (b.isNegative()) {
     b = -b;
     negative = !negative;
   }
   // If b == 2^n, bpower will be n, otherwise it will be -1.
   int bpower = b._powerOfTwo();

   // True if the original value of a is negative.
   bool aIsNegative = false;
   // True if the original value of a is int64.MIN_VALUE.
   bool aIsMinValue = false;

   /*
    * Normalize a to a positive value, keeping track of the sign change in
    * 'negative' (which tracks the sign of both a and b and is used to
    * determine the sign of the quotient) and 'aIsNegative' (which is used to
    * determine the sign of the remainder).
    *
    * For all values of a except MIN_VALUE, we can just negate a and modify
    * negative and aIsNegative appropriately. When a == MIN_VALUE, negation is
    * not possible without overflowing 64 bits, so instead of computing
    * abs(MIN_VALUE) / abs(b) we compute (abs(MIN_VALUE) - 1) / abs(b). The
    * only circumstance under which these quotients differ is when b is a power
    * of two, which will divide abs(MIN_VALUE) == 2^64 exactly. In this case,
    * we can get the proper result by shifting MIN_VALUE in unsigned fashion.
    *
    * We make a single copy of a before the first operation that needs to
    * modify its value.
    */
   bool aIsCopy = false;
   if (a.isMinValue()) {
     aIsMinValue = true;
     aIsNegative = true;
     // If b is not a power of two, treat -a as MAX_VALUE (instead of the
     // actual value (MAX_VALUE + 1)).
     if (bpower == -1) {
       a = new int64._copy(MAX_VALUE);
       aIsCopy = true;
       negative = !negative;
     } else {
       // Signed shift of MIN_VALUE produces the right answer.
       int64 c = a &gt;&gt; bpower;
       if (negative) {
         c._negate();
       }
       if (computeRemainder) {
         _remainder = ZERO;
       }
       return c;
     }
   } else if (a.isNegative()) {
     aIsNegative = true;
     a = -a;
     aIsCopy = true;
     negative = !negative;
   }

   // Now both a and b are non-negative.
   // If b is a power of two, just shift.
   if (bpower != -1) {
     return _divModByShift(a, bpower, negative, aIsCopy, aIsNegative,
       computeRemainder);
   }

   // If a &lt; b, the quotient is 0 and the remainder is a.
   if (a &lt; b) {
     if (computeRemainder) {
       if (aIsNegative) {
         _remainder = -a;
       } else {
         _remainder = aIsCopy ? a : new int64._copy(a);
       }
     }
     return ZERO;
   }

   // Generate the quotient using bit-at-a-time long division.
   return _divModHelper(aIsCopy ? a : new int64._copy(a), b, negative,
       aIsNegative, aIsMinValue, computeRemainder);
 }
}
</pre>
</div>
<h3>Implements</h3>
<p>
<span class="type-box"><span class="icon-class"></span><a href="../fixnum/intx.html">intx</a></span></p>
<div>
<h3>Static Properties</h3>
<div class="field"><h4 id="MAX_VALUE">
<button class="show-code">Code</button>
final <a href="../fixnum/int64.html">int64</a>         <strong>MAX_VALUE</strong> <a class="anchor-link"
            href="#MAX_VALUE"
            title="Permalink to int64.MAX_VALUE">#</a>
        </h4>
        <div class="doc">
<p>The maximum positive value attainable by an <a class="crossref" href="../fixnum/int64.html#int64">int64</a>, namely
9,223,372,036,854,775,807.</p>
<pre class="source">
static int64 get MAX_VALUE {
 if (_MAX_VALUE == null) {
   _MAX_VALUE = new int64._bits(_MASK, _MASK, _MASK_2 &gt;&gt; 1);
 }
 return _MAX_VALUE;
}
</pre>
</div>
</div>
<div class="field"><h4 id="MIN_VALUE">
<button class="show-code">Code</button>
final <a href="../fixnum/int64.html">int64</a>         <strong>MIN_VALUE</strong> <a class="anchor-link"
            href="#MIN_VALUE"
            title="Permalink to int64.MIN_VALUE">#</a>
        </h4>
        <div class="doc">
<p>The minimum positive value attainable by an <a class="crossref" href="../fixnum/int64.html#int64">int64</a>, namely
-9,223,372,036,854,775,808.</p>
<pre class="source">
static int64 get MIN_VALUE {
 if (_MIN_VALUE == null) {
   _MIN_VALUE = new int64._bits(0, 0, _SIGN_BIT_VALUE);
 }
 return _MIN_VALUE;
}
</pre>
</div>
</div>
<div class="field"><h4 id="ONE">
<button class="show-code">Code</button>
final <a href="../fixnum/int64.html">int64</a>         <strong>ONE</strong> <a class="anchor-link"
            href="#ONE"
            title="Permalink to int64.ONE">#</a>
        </h4>
        <div class="doc">
<p>An <a class="crossref" href="../fixnum/int64.html#int64">int64</a> constant equal to 1.</p>
<pre class="source">
static int64 get ONE {
 if (_ONE == null) {
   _ONE = new int64._bits(1, 0, 0);
 }
 return _ONE;
}
</pre>
</div>
</div>
<div class="field"><h4 id="TWO">
<button class="show-code">Code</button>
final <a href="../fixnum/int64.html">int64</a>         <strong>TWO</strong> <a class="anchor-link"
            href="#TWO"
            title="Permalink to int64.TWO">#</a>
        </h4>
        <div class="doc">
<p>An <a class="crossref" href="../fixnum/int64.html#int64">int64</a> constant equal to 2.</p>
<pre class="source">
static int64 get TWO {
 if (_TWO == null) {
   _TWO = new int64._bits(2, 0, 0);
 }
 return _TWO;
}
</pre>
</div>
</div>
<div class="field"><h4 id="ZERO">
<button class="show-code">Code</button>
final <a href="../fixnum/int64.html">int64</a>         <strong>ZERO</strong> <a class="anchor-link"
            href="#ZERO"
            title="Permalink to int64.ZERO">#</a>
        </h4>
        <div class="doc">
<p>An <a class="crossref" href="../fixnum/int64.html#int64">int64</a> constant equal to 0.</p>
<pre class="source">
static int64 get ZERO {
 if (_ZERO == null) {
   _ZERO = new int64();
 }
 return _ZERO;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="parseRadix">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>parseRadix</strong>(String s, int radix) <a class="anchor-link" href="#parseRadix"
              title="Permalink to int64.parseRadix">#</a></h4>
<div class="doc">
<p>Parses a <code>String</code> in a given 
<span class="param">radix</span> between 2 and 16 and returns an
<a class="crossref" href="../fixnum/int64.html#int64">int64</a>.</p>
<pre class="source">
static int64 parseRadix(String s, int radix) {
 if ((radix &lt;= 1) || (radix &gt; 16)) {
   throw "Bad radix: $radix";
 }
 int64 x = ZERO;
 int i = 0;
 bool negative = false;
 if (s[0] == '-') {
   negative = true;
   i++;
 }
 for (; i &lt; s.length; i++) {
   int c = s.codeUnitAt(i);
   int digit = int32._decodeHex(c);
   if (digit &lt; 0 || digit &gt;= radix) {
     throw new Exception("Non-radix char code: $c");
   }
   x = (x * radix) + digit;
 }
 return negative ? -x : x;
}
</pre>
</div>
</div>
<div class="method"><h4 id="parseInt">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>parseInt</strong>(String s) <a class="anchor-link" href="#parseInt"
              title="Permalink to int64.parseInt">#</a></h4>
<div class="doc">
<p>Parses a decimal <code>String</code> and returns an <a class="crossref" href="../fixnum/int64.html#int64">int64</a>.</p>
<pre class="source">
static int64 parseInt(String s) =&gt; parseRadix(s, 10);
</pre>
</div>
</div>
<div class="method"><h4 id="parseHex">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>parseHex</strong>(String s) <a class="anchor-link" href="#parseHex"
              title="Permalink to int64.parseHex">#</a></h4>
<div class="doc">
<p>Parses a hexadecimal <code>String</code> and returns an <a class="crossref" href="../fixnum/int64.html#int64">int64</a>.</p>
<pre class="source">
static int64 parseHex(String s) =&gt; parseRadix(s, 16);
</pre>
</div>
</div>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="int64">
<button class="show-code">Code</button>
new <strong>int64</strong>() <a class="anchor-link" href="#int64"
              title="Permalink to int64.int64">#</a></h4>
<div class="doc">
<p>Constructs an <a class="crossref" href="../fixnum/int64.html#int64">int64</a> equal to 0.</p>
<pre class="source">
int64() : _l = 0, _m = 0, _h = 0;
</pre>
</div>
</div>
<div class="method"><h4 id="int64.fromBytes">
<button class="show-code">Code</button>
factory <strong>int64.fromBytes</strong>(List&lt;int&gt; bytes) <a class="anchor-link" href="#int64.fromBytes"
              title="Permalink to int64.int64.fromBytes">#</a></h4>
<div class="doc">
<pre class="source">
factory int64.fromBytes(List&lt;int&gt; bytes) {
 int top = bytes[7] &amp; 0xff;
 top &lt;&lt;= 8;
 top |= bytes[6] &amp; 0xff;
 top &lt;&lt;= 8;
 top |= bytes[5] &amp; 0xff;
 top &lt;&lt;= 8;
 top |= bytes[4] &amp; 0xff;

 int bottom = bytes[3] &amp; 0xff;
 bottom &lt;&lt;= 8;
 bottom |= bytes[2] &amp; 0xff;
 bottom &lt;&lt;= 8;
 bottom |= bytes[1] &amp; 0xff;
 bottom &lt;&lt;= 8;
 bottom |= bytes[0] &amp; 0xff;

 return new int64.fromInts(top, bottom);
}
</pre>
</div>
</div>
<div class="method"><h4 id="int64.fromBytesBigEndian">
<button class="show-code">Code</button>
factory <strong>int64.fromBytesBigEndian</strong>(List&lt;int&gt; bytes) <a class="anchor-link" href="#int64.fromBytesBigEndian"
              title="Permalink to int64.int64.fromBytesBigEndian">#</a></h4>
<div class="doc">
<pre class="source">
factory int64.fromBytesBigEndian(List&lt;int&gt; bytes) {
 int top = bytes[0] &amp; 0xff;
 top &lt;&lt;= 8;
 top |= bytes[1] &amp; 0xff;
 top &lt;&lt;= 8;
 top |= bytes[2] &amp; 0xff;
 top &lt;&lt;= 8;
 top |= bytes[3] &amp; 0xff;

 int bottom = bytes[4] &amp; 0xff;
 bottom &lt;&lt;= 8;
 bottom |= bytes[5] &amp; 0xff;
 bottom &lt;&lt;= 8;
 bottom |= bytes[6] &amp; 0xff;
 bottom &lt;&lt;= 8;
 bottom |= bytes[7] &amp; 0xff;

 return new int64.fromInts(top, bottom);
}
</pre>
</div>
</div>
<div class="method"><h4 id="int64.fromInt">
<button class="show-code">Code</button>
new <strong>int64.fromInt</strong>(int value) <a class="anchor-link" href="#int64.fromInt"
              title="Permalink to int64.int64.fromInt">#</a></h4>
<div class="doc">
<p>Constructs an <a class="crossref" href="../fixnum/int64.html#int64">int64</a> with a given <code>int</code> value.</p>
<pre class="source">
int64.fromInt(int value) {
 bool negative = false;
 if (value &lt; 0) {
   negative = true;
   value = -value - 1;
 }
 if (_haveBigInts) {
   _l = value &amp; _MASK;
   _m = (value &gt;&gt; _BITS) &amp; _MASK;
   _h = (value &gt;&gt; _BITS01) &amp; _MASK_2;
 } else {
   // Avoid using bitwise operations that coerce their input to 32 bits.
   _h = value ~/ 17592186044416; // 2^44
   value -= _h * 17592186044416;
   _m = value ~/ 4194304; // 2^22
   value -= _m * 4194304;
   _l = value;
 }

 if (negative) {
   _l = ~_l &amp; _MASK;
   _m = ~_m &amp; _MASK;
   _h = ~_h &amp; _MASK_2;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="int64.fromInts">
<button class="show-code">Code</button>
new <strong>int64.fromInts</strong>(int top, int bottom) <a class="anchor-link" href="#int64.fromInts"
              title="Permalink to int64.int64.fromInts">#</a></h4>
<div class="doc">
<p>Constructs an <a class="crossref" href="../fixnum/int64.html#int64">int64</a> from a pair of 32-bit integers having the value
<code>((top &amp; 0xffffffff) &lt;&lt; 32) | (bottom &amp; 0xffffffff)</code>.</p>
<pre class="source">
int64.fromInts(int top, int bottom) {
 top &amp;= 0xffffffff;
 bottom &amp;= 0xffffffff;
 _l = bottom &amp; _MASK;
 _m = ((top &amp; 0xfff) &lt;&lt; 10) | ((bottom &gt;&gt; _BITS) &amp; 0x3ff);
 _h = (top &gt;&gt; 12) &amp; _MASK_2;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="hashCode">
<button class="show-code">Code</button>
final int         <strong>hashCode</strong> <a class="anchor-link"
            href="#hashCode"
            title="Permalink to int64.hashCode">#</a>
        </h4>
        <div class="doc">
<p>Returns a hash code based on all the bits of this <a class="crossref" href="../fixnum/int64.html#int64">int64</a>.</p>
<pre class="source">
int get hashCode {
 int bottom = ((_m &amp; 0x3ff) &lt;&lt; _BITS) | _l;
 int top = (_h &lt;&lt; 12) | ((_m &gt;&gt; 10) &amp; 0xfff);
 return bottom ^ top;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Operators</h3>
<div class="method"><h4 id="+">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>operator +</strong>(other) <a class="anchor-link" href="#+"
              title="Permalink to int64.operator +">#</a></h4>
<div class="doc">
<pre class="source">
int64 operator +(other) {
 int64 o = _promote(other);
 int sum0 = _l + o._l;
 int sum1 = _m + o._m + _shiftRight(sum0, _BITS);
 int sum2 = _h + o._h + _shiftRight(sum1, _BITS);

 int64 result = new int64._bits(sum0 &amp; _MASK, sum1 &amp; _MASK, sum2 &amp; _MASK_2);
 return result;
}
</pre>
</div>
</div>
<div class="method"><h4 id="unary-">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>operator -</strong>() <a class="anchor-link" href="#unary-"
              title="Permalink to int64.operator -">#</a></h4>
<div class="doc">
<pre class="source">
int64 operator -() {
 // Like 0 - this.
 int sum0 = -_l;
 int sum1 = -_m + _shiftRight(sum0, _BITS);
 int sum2 = -_h + _shiftRight(sum1, _BITS);

 return new int64._bits(sum0 &amp; _MASK, sum1 &amp; _MASK, sum2 &amp; _MASK_2);
}
</pre>
</div>
</div>
<div class="method"><h4 id="-">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>operator -</strong>(other) <a class="anchor-link" href="#-"
              title="Permalink to int64.operator -">#</a></h4>
<div class="doc">
<pre class="source">
int64 operator -(other) {
 int64 o = _promote(other);

 int sum0 = _l - o._l;
 int sum1 = _m - o._m + _shiftRight(sum0, _BITS);
 int sum2 = _h - o._h + _shiftRight(sum1, _BITS);

 int64 result = new int64._bits(sum0 &amp; _MASK, sum1 &amp; _MASK, sum2 &amp; _MASK_2);
 return result;
}
</pre>
</div>
</div>
<div class="method"><h4 id="*">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>operator *</strong>(other) <a class="anchor-link" href="#*"
              title="Permalink to int64.operator *">#</a></h4>
<div class="doc">
<pre class="source">
int64 operator *(other) {
 int64 o = _promote(other);
 // Grab 13-bit chunks.
 int a0 = _l &amp; 0x1fff;
 int a1 = (_l &gt;&gt; 13) | ((_m &amp; 0xf) &lt;&lt; 9);
 int a2 = (_m &gt;&gt; 4) &amp; 0x1fff;
 int a3 = (_m &gt;&gt; 17) | ((_h &amp; 0xff) &lt;&lt; 5);
 int a4 = (_h &amp; 0xfff00) &gt;&gt; 8;

 int b0 = o._l &amp; 0x1fff;
 int b1 = (o._l &gt;&gt; 13) | ((o._m &amp; 0xf) &lt;&lt; 9);
 int b2 = (o._m &gt;&gt; 4) &amp; 0x1fff;
 int b3 = (o._m &gt;&gt; 17) | ((o._h &amp; 0xff) &lt;&lt; 5);
 int b4 = (o._h &amp; 0xfff00) &gt;&gt; 8;

 // Compute partial products.
 // Optimization: if b is small, avoid multiplying by parts that are 0.
 int p0 = a0 * b0; // &lt;&lt; 0
 int p1 = a1 * b0; // &lt;&lt; 13
 int p2 = a2 * b0; // &lt;&lt; 26
 int p3 = a3 * b0; // &lt;&lt; 39
 int p4 = a4 * b0; // &lt;&lt; 52

 if (b1 != 0) {
   p1 += a0 * b1;
   p2 += a1 * b1;
   p3 += a2 * b1;
   p4 += a3 * b1;
 }
 if (b2 != 0) {
   p2 += a0 * b2;
   p3 += a1 * b2;
   p4 += a2 * b2;
 }
 if (b3 != 0) {
   p3 += a0 * b3;
   p4 += a1 * b3;
 }
 if (b4 != 0) {
   p4 += a0 * b4;
 }

 // Accumulate into 22-bit chunks:
 // .........................................c10|...................c00|
 // |....................|..................xxxx|xxxxxxxxxxxxxxxxxxxxxx| p0
 // |....................|......................|......................|
 // |....................|...................c11|......c01.............|
 // |....................|....xxxxxxxxxxxxxxxxxx|xxxxxxxxx.............| p1
 // |....................|......................|......................|
 // |.................c22|...............c12....|......................|
 // |..........xxxxxxxxxx|xxxxxxxxxxxxxxxxxx....|......................| p2
 // |....................|......................|......................|
 // |.................c23|..c13.................|......................|
 // |xxxxxxxxxxxxxxxxxxxx|xxxxx.................|......................| p3
 // |....................|......................|......................|
 // |.........c24........|......................|......................|
 // |xxxxxxxxxxxx........|......................|......................| p4

 int c00 = p0 &amp; 0x3fffff;
 int c01 = (p1 &amp; 0x1ff) &lt;&lt; 13;
 int c0 = c00 + c01;

 int c10 = p0 &gt;&gt; 22;
 int c11 = p1 &gt;&gt; 9;
 int c12 = (p2 &amp; 0x3ffff) &lt;&lt; 4;
 int c13 = (p3 &amp; 0x1f) &lt;&lt; 17;
 int c1 = c10 + c11 + c12 + c13;

 int c22 = p2 &gt;&gt; 18;
 int c23 = p3 &gt;&gt; 5;
 int c24 = (p4 &amp; 0xfff) &lt;&lt; 8;
 int c2 = c22 + c23 + c24;

 // Propagate high bits from c0 -&gt; c1, c1 -&gt; c2.
 c1 += c0 &gt;&gt; _BITS;
 c0 &amp;= _MASK;
 c2 += c1 &gt;&gt; _BITS;
 c1 &amp;= _MASK;
 c2 &amp;= _MASK_2;

 return new int64._bits(c0, c1, c2);
}
</pre>
</div>
</div>
<div class="method"><h4 id="~/">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>operator ~/</strong>(other) <a class="anchor-link" href="#~/"
              title="Permalink to int64.operator ~/">#</a></h4>
<div class="doc">
<pre class="source">
int64 operator ~/(other) =&gt; _divMod(this, _promote(other), false);
</pre>
</div>
</div>
<div class="method"><h4 id="%">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>operator %</strong>(other) <a class="anchor-link" href="#%"
              title="Permalink to int64.operator %">#</a></h4>
<div class="doc">
<pre class="source">
int64 operator %(other) {
 if (other.isZero()) {
   throw new IntegerDivisionByZeroException();
 }
 if (this.isZero()) {
   return ZERO;
 }
 int64 o = _promote(other).abs();
 _divMod(this, o, true);
 return _remainder &lt; 0 ? (_remainder + o) : _remainder;
}
</pre>
</div>
</div>
<div class="method"><h4 id="&">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>operator &</strong>(other) <a class="anchor-link" href="#&"
              title="Permalink to int64.operator &">#</a></h4>
<div class="doc">
<pre class="source">
int64 operator &amp;(other) {
 int64 o = _promote(other);
 int a0 = _l &amp; o._l;
 int a1 = _m &amp; o._m;
 int a2 = _h &amp; o._h;
 return new int64._bits(a0, a1, a2);
}
</pre>
</div>
</div>
<div class="method"><h4 id="|">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>operator |</strong>(other) <a class="anchor-link" href="#|"
              title="Permalink to int64.operator |">#</a></h4>
<div class="doc">
<pre class="source">
int64 operator |(other) {
 int64 o = _promote(other);
 int a0 = _l | o._l;
 int a1 = _m | o._m;
 int a2 = _h | o._h;
 return new int64._bits(a0, a1, a2);
}
</pre>
</div>
</div>
<div class="method"><h4 id="^">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>operator ^</strong>(other) <a class="anchor-link" href="#^"
              title="Permalink to int64.operator ^">#</a></h4>
<div class="doc">
<pre class="source">
int64 operator ^(other) {
 int64 o = _promote(other);
 int a0 = _l ^ o._l;
 int a1 = _m ^ o._m;
 int a2 = _h ^ o._h;
 return new int64._bits(a0, a1, a2);
}
</pre>
</div>
</div>
<div class="method"><h4 id="~">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>operator ~</strong>() <a class="anchor-link" href="#~"
              title="Permalink to int64.operator ~">#</a></h4>
<div class="doc">
<pre class="source">
int64 operator ~() {
 var result = new int64._bits((~_l) &amp; _MASK, (~_m) &amp; _MASK, (~_h) &amp; _MASK_2);
 return result;
}
</pre>
</div>
</div>
<div class="method"><h4 id="<<">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>operator <<</strong>(int n) <a class="anchor-link" href="#<<"
              title="Permalink to int64.operator <<">#</a></h4>
<div class="doc">
<pre class="source">
int64 operator &lt;&lt;(int n) {
 if (n &lt; 0) {
   throw new ArgumentError("$n");
 }
 n &amp;= 63;

 int res0, res1, res2;
 if (n &lt; _BITS) {
   res0 = _l &lt;&lt; n;
   res1 = (_m &lt;&lt; n) | (_l &gt;&gt; (_BITS - n));
   res2 = (_h &lt;&lt; n) | (_m &gt;&gt; (_BITS - n));
 } else if (n &lt; _BITS01) {
   res0 = 0;
   res1 = _l &lt;&lt; (n - _BITS);
   res2 = (_m &lt;&lt; (n - _BITS)) | (_l &gt;&gt; (_BITS01 - n));
 } else {
   res0 = 0;
   res1 = 0;
   res2 = _l &lt;&lt; (n - _BITS01);
 }

 return new int64._bits(res0 &amp; _MASK, res1 &amp; _MASK, res2 &amp; _MASK_2);
}
</pre>
</div>
</div>
<div class="method"><h4 id=">>">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>operator >></strong>(int n) <a class="anchor-link" href="#>>"
              title="Permalink to int64.operator >>">#</a></h4>
<div class="doc">
<pre class="source">
int64 operator &gt;&gt;(int n) {
 if (n &lt; 0) {
   throw new ArgumentError("$n");
 }
 n &amp;= 63;

 int res0, res1, res2;

 // Sign extend h(a).
 int a2 = _h;
 bool negative = (a2 &amp; _SIGN_BIT_VALUE) != 0;
 if (negative) {
   a2 += 0x3 &lt;&lt; _BITS2; // add extra one bits on the left
 }

 if (n &lt; _BITS) {
   res2 = _shiftRight(a2, n);
   if (negative) {
     res2 |= _MASK_2 &amp; ~(_MASK_2 &gt;&gt; n);
   }
   res1 = _shiftRight(_m, n) | (a2 &lt;&lt; (_BITS - n));
   res0 = _shiftRight(_l, n) | (_m &lt;&lt; (_BITS - n));
 } else if (n &lt; _BITS01) {
   res2 = negative ? _MASK_2 : 0;
   res1 = _shiftRight(a2, n - _BITS);
   if (negative) {
     res1 |= _MASK &amp; ~(_MASK &gt;&gt; (n - _BITS));
   }
   res0 = _shiftRight(_m, n - _BITS) | (a2 &lt;&lt; (_BITS01 - n));
 } else {
   res2 = negative ? _MASK_2 : 0;
   res1 = negative ? _MASK : 0;
   res0 = _shiftRight(a2, n - _BITS01);
   if (negative) {
     res0 |= _MASK &amp; ~(_MASK &gt;&gt; (n - _BITS01));
   }
 }

 return new int64._bits(res0 &amp; _MASK, res1 &amp; _MASK, res2 &amp; _MASK_2);
}
</pre>
</div>
</div>
<div class="method"><h4 id="<">
<button class="show-code">Code</button>
bool <strong>operator <</strong>(other) <a class="anchor-link" href="#<"
              title="Permalink to int64.operator <">#</a></h4>
<div class="doc">
<pre class="source">
bool operator &lt;(other) {
 return this.compareTo(other) &lt; 0;
}
</pre>
</div>
</div>
<div class="method"><h4 id="<=">
<button class="show-code">Code</button>
bool <strong>operator <=</strong>(other) <a class="anchor-link" href="#<="
              title="Permalink to int64.operator <=">#</a></h4>
<div class="doc">
<pre class="source">
bool operator &lt;=(other) {
 return this.compareTo(other) &lt;= 0;
}
</pre>
</div>
</div>
<div class="method"><h4 id=">">
<button class="show-code">Code</button>
bool <strong>operator ></strong>(other) <a class="anchor-link" href="#>"
              title="Permalink to int64.operator >">#</a></h4>
<div class="doc">
<pre class="source">
bool operator &gt;(other) {
 return this.compareTo(other) &gt; 0;
}
</pre>
</div>
</div>
<div class="method"><h4 id=">=">
<button class="show-code">Code</button>
bool <strong>operator >=</strong>(other) <a class="anchor-link" href="#>="
              title="Permalink to int64.operator >=">#</a></h4>
<div class="doc">
<pre class="source">
bool operator &gt;=(other) {
 return this.compareTo(other) &gt;= 0;
}
</pre>
</div>
</div>
<div class="method"><h4 id="==">
<button class="show-code">Code</button>
bool <strong>operator ==</strong>(other) <a class="anchor-link" href="#=="
              title="Permalink to int64.operator ==">#</a></h4>
<div class="doc">
<p>Returns <code>true</code> if this <a class="crossref" href="../fixnum/int64.html#int64">int64</a> has the same numeric value as the
given object.  The argument may be an <code>int</code> or an <a class="crossref" href="../fixnum/intx.html">intx</a>.</p>
<pre class="source">
bool operator ==(other) {
 if (other == null) {
   return false;
 }
 int64 o = _promote(other);
 return _l == o._l &amp;&amp; _m == o._m &amp;&amp; _h == o._h;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="abs">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>abs</strong>() <a class="anchor-link" href="#abs"
              title="Permalink to int64.abs">#</a></h4>
<div class="doc">
<pre class="source">
int64 abs() {
 return this &lt; 0 ? -this : this;
}
</pre>
</div>
</div>
<div class="method"><h4 id="compareTo">
<button class="show-code">Code</button>
int <strong>compareTo</strong>(Comparable other) <a class="anchor-link" href="#compareTo"
              title="Permalink to int64.compareTo">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Compares this object to another <code>Comparable</code></p>
<p>Returns a value like a <code>Comparator</code> when comparing <code>this</code> to 
<span class="param">other</span>.</p>
<p>May throw an <code>ArgumentError</code> if 
<span class="param">other</span> is of a type that
is not comparable to <code>this</code>.</p>
<div class="docs-inherited-from">docs inherited from Comparable </div></div>
<pre class="source">
int compareTo(Comparable other) {
 int64 o = _promote(other);
 int signa = _h &gt;&gt; (_BITS2 - 1);
 int signb = o._h &gt;&gt; (_BITS2 - 1);
 if (signa != signb) {
   return signa == 0 ? 1 : -1;
 }
 if (_h &gt; o._h) {
   return 1;
 } else if (_h &lt; o._h) {
   return -1;
 }
 if (_m &gt; o._m) {
   return 1;
 } else if (_m &lt; o._m) {
   return -1;
 }
 if (_l &gt; o._l) {
   return 1;
 } else if (_l &lt; o._l) {
   return -1;
 }
 return 0;
}
</pre>
</div>
</div>
<div class="method"><h4 id="isEven">
<button class="show-code">Code</button>
bool <strong>isEven</strong>() <a class="anchor-link" href="#isEven"
              title="Permalink to int64.isEven">#</a></h4>
<div class="doc">
<pre class="source">
bool isEven() =&gt; (_l &amp; 0x1) == 0;
</pre>
</div>
</div>
<div class="method"><h4 id="isMaxValue">
<button class="show-code">Code</button>
bool <strong>isMaxValue</strong>() <a class="anchor-link" href="#isMaxValue"
              title="Permalink to int64.isMaxValue">#</a></h4>
<div class="doc">
<pre class="source">
bool isMaxValue() =&gt; (_h == _MASK_2 &gt;&gt; 1) &amp;&amp; _m == _MASK &amp;&amp; _l == _MASK;
</pre>
</div>
</div>
<div class="method"><h4 id="isMinValue">
<button class="show-code">Code</button>
bool <strong>isMinValue</strong>() <a class="anchor-link" href="#isMinValue"
              title="Permalink to int64.isMinValue">#</a></h4>
<div class="doc">
<pre class="source">
bool isMinValue() =&gt; _h == _SIGN_BIT_VALUE &amp;&amp; _m == 0 &amp;&amp; _l == 0;
</pre>
</div>
</div>
<div class="method"><h4 id="isNegative">
<button class="show-code">Code</button>
bool <strong>isNegative</strong>() <a class="anchor-link" href="#isNegative"
              title="Permalink to int64.isNegative">#</a></h4>
<div class="doc">
<pre class="source">
bool isNegative() =&gt; (_h &gt;&gt; (_BITS2 - 1)) != 0;
</pre>
</div>
</div>
<div class="method"><h4 id="isOdd">
<button class="show-code">Code</button>
bool <strong>isOdd</strong>() <a class="anchor-link" href="#isOdd"
              title="Permalink to int64.isOdd">#</a></h4>
<div class="doc">
<pre class="source">
bool isOdd() =&gt; (_l &amp; 0x1) == 1;
</pre>
</div>
</div>
<div class="method"><h4 id="isZero">
<button class="show-code">Code</button>
bool <strong>isZero</strong>() <a class="anchor-link" href="#isZero"
              title="Permalink to int64.isZero">#</a></h4>
<div class="doc">
<pre class="source">
bool isZero() =&gt; _h == 0 &amp;&amp; _m == 0 &amp;&amp; _l == 0;
</pre>
</div>
</div>
<div class="method"><h4 id="numberOfLeadingZeros">
<button class="show-code">Code</button>
int <strong>numberOfLeadingZeros</strong>() <a class="anchor-link" href="#numberOfLeadingZeros"
              title="Permalink to int64.numberOfLeadingZeros">#</a></h4>
<div class="doc">
<p>Returns the number of leading zeros in this <a class="crossref" href="../fixnum/int64.html#int64">int64</a> as an <code>int</code>
between 0 and 64.</p>
<pre class="source">
int numberOfLeadingZeros() {
 int b2 = int32._numberOfLeadingZeros(_h);
 if (b2 == 32) {
   int b1 = int32._numberOfLeadingZeros(_m);
   if (b1 == 32) {
     return int32._numberOfLeadingZeros(_l) + 32;
   } else {
     return b1 + _BITS2 - (32 - _BITS);
   }
 } else {
   return b2 - (32 - _BITS2);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="numberOfTrailingZeros">
<button class="show-code">Code</button>
int <strong>numberOfTrailingZeros</strong>() <a class="anchor-link" href="#numberOfTrailingZeros"
              title="Permalink to int64.numberOfTrailingZeros">#</a></h4>
<div class="doc">
<p>Returns the number of trailing zeros in this <a class="crossref" href="../fixnum/int64.html#int64">int64</a> as an <code>int</code>
between 0 and 64.</p>
<pre class="source">
int numberOfTrailingZeros() {
 int zeros = int32._numberOfTrailingZeros(_l);
 if (zeros &lt; 32) {
   return zeros;
 }

 zeros = int32._numberOfTrailingZeros(_m);
 if (zeros &lt; 32) {
   return _BITS + zeros;
 }

 zeros = int32._numberOfTrailingZeros(_h);
 if (zeros &lt; 32) {
   return _BITS01 + zeros;
 }
 // All zeros
 return 64;
}
</pre>
</div>
</div>
<div class="method"><h4 id="remainder">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>remainder</strong>(other) <a class="anchor-link" href="#remainder"
              title="Permalink to int64.remainder">#</a></h4>
<div class="doc">
<pre class="source">
int64 remainder(other) {
 if (other.isZero()) {
   throw new IntegerDivisionByZeroException();
 }
 int64 o = _promote(other).abs();
 _divMod(this, o, true);
 return _remainder;
}
</pre>
</div>
</div>
<div class="method"><h4 id="shiftRightUnsigned">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>shiftRightUnsigned</strong>(int n) <a class="anchor-link" href="#shiftRightUnsigned"
              title="Permalink to int64.shiftRightUnsigned">#</a></h4>
<div class="doc">
<pre class="source">
int64 shiftRightUnsigned(int n) {
 if (n &lt; 0) {
   throw new ArgumentError("$n");
 }
 n &amp;= 63;

 int res0, res1, res2;
 int a2 = _h &amp; _MASK_2; // Ensure a2 is positive.
 if (n &lt; _BITS) {
   res2 = a2 &gt;&gt; n;
   res1 = (_m &gt;&gt; n) | (a2 &lt;&lt; (_BITS - n));
   res0 = (_l &gt;&gt; n) | (_m &lt;&lt; (_BITS - n));
 } else if (n &lt; _BITS01) {
   res2 = 0;
   res1 = a2 &gt;&gt; (n - _BITS);
   res0 = (_m &gt;&gt; (n - _BITS)) | (_h &lt;&lt; (_BITS01 - n));
 } else {
   res2 = 0;
   res1 = 0;
   res0 = a2 &gt;&gt; (n - _BITS01);
 }

 return new int64._bits(res0 &amp; _MASK, res1 &amp; _MASK, res2 &amp; _MASK_2);
}
</pre>
</div>
</div>
<div class="method"><h4 id="toBytes">
<button class="show-code">Code</button>
List&lt;int&gt; <strong>toBytes</strong>() <a class="anchor-link" href="#toBytes"
              title="Permalink to int64.toBytes">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Converts this <a class="crossref" href="../fixnum/intx.html">intx</a> to a <code>List</code> of <code>int</code>, starting with the least
significant byte.</p>
<div class="docs-inherited-from">docs inherited from <a href="../fixnum/intx.html">intx</a> </div></div>
<pre class="source">
List&lt;int&gt; toBytes() {
 List&lt;int&gt; result = new List&lt;int&gt;.fixedLength(8);
 result[0] = _l &amp; 0xff;
 result[1] = (_l &gt;&gt; 8) &amp; 0xff;
 result[2] = ((_m &lt;&lt; 6) &amp; 0xfc) | ((_l &gt;&gt; 16) &amp; 0x3f);
 result[3] = (_m &gt;&gt; 2) &amp; 0xff;
 result[4] = (_m &gt;&gt; 10) &amp; 0xff;
 result[5] = ((_h &lt;&lt; 4) &amp; 0xf0) | ((_m &gt;&gt; 18) &amp; 0xf);
 result[6] = (_h &gt;&gt; 4) &amp; 0xff;
 result[7] = (_h &gt;&gt; 12) &amp; 0xff;
 return result;
}
</pre>
</div>
</div>
<div class="method"><h4 id="toDebugString">
<button class="show-code">Code</button>
String <strong>toDebugString</strong>() <a class="anchor-link" href="#toDebugString"
              title="Permalink to int64.toDebugString">#</a></h4>
<div class="doc">
<pre class="source">
String toDebugString() {
 return "int64[_l=$_l, _m=$_m, _h=$_h]";
}
</pre>
</div>
</div>
<div class="method"><h4 id="toHexString">
<button class="show-code">Code</button>
String <strong>toHexString</strong>() <a class="anchor-link" href="#toHexString"
              title="Permalink to int64.toHexString">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Returns the value of this <a class="crossref" href="../fixnum/intx.html">intx</a> as a hexadecimal <code>String</code>.</p>
<div class="docs-inherited-from">docs inherited from <a href="../fixnum/intx.html">intx</a> </div></div>
<pre class="source">
String toHexString() {
 int64 x = new int64._copy(this);
 if (isZero()) {
   return "0";
 }
 String hexStr = "";
 int64 digit_f = new int64.fromInt(0xf);
 while (!x.isZero()) {
   int digit = x._l &amp; 0xf;
   hexStr = "${_hexDigit(digit)}$hexStr";
   x = x.shiftRightUnsigned(4);
 }
 return hexStr;
}
</pre>
</div>
</div>
<div class="method"><h4 id="toInt">
<button class="show-code">Code</button>
int <strong>toInt</strong>() <a class="anchor-link" href="#toInt"
              title="Permalink to int64.toInt">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Converts this <a class="crossref" href="../fixnum/intx.html">intx</a> to an <code>int</code>.  On some platforms, inputs with large
absolute values (i.e., > 2^52) may lose some of their low bits.</p>
<div class="docs-inherited-from">docs inherited from <a href="../fixnum/intx.html">intx</a> </div></div>
<pre class="source">
int toInt() {
 int l = _l;
 int m = _m;
 int h = _h;
 bool negative = false;
 if ((_h &amp; _SIGN_BIT_VALUE) != 0) {
   l = ~_l &amp; _MASK;
   m = ~_m &amp; _MASK;
   h = ~_h &amp; _MASK_2;
   negative = true;
 }

 int result;
 if (_haveBigInts) {
   result = (h &lt;&lt; _BITS01) | (m &lt;&lt; _BITS) | l;
 } else {
   result = (h * 17592186044416) + (m * 4194304) + l;
 }
 return negative ? -result - 1 : result;
}
</pre>
</div>
</div>
<div class="method"><h4 id="toInt32">
<button class="show-code">Code</button>
<a href="../fixnum/int32.html">int32</a> <strong>toInt32</strong>() <a class="anchor-link" href="#toInt32"
              title="Permalink to int64.toInt32">#</a></h4>
<div class="doc">
<p>Returns an <a class="crossref" href="../fixnum/int32.html">int32</a> containing the low 32 bits of this <a class="crossref" href="../fixnum/int64.html#int64">int64</a>.</p>
<pre class="source">
int32 toInt32() {
 return new int32.fromInt(((_m &amp; 0x3ff) &lt;&lt; _BITS) | _l);
}
</pre>
</div>
</div>
<div class="method"><h4 id="toInt64">
<button class="show-code">Code</button>
<a href="../fixnum/int64.html">int64</a> <strong>toInt64</strong>() <a class="anchor-link" href="#toInt64"
              title="Permalink to int64.toInt64">#</a></h4>
<div class="doc">
<p>Returns <code>this</code>.</p>
<pre class="source">
int64 toInt64() =&gt; this;
</pre>
</div>
</div>
<div class="method"><h4 id="toRadixString">
<button class="show-code">Code</button>
String <strong>toRadixString</strong>(int radix) <a class="anchor-link" href="#toRadixString"
              title="Permalink to int64.toRadixString">#</a></h4>
<div class="doc">
<div class="inherited">
<p>Returns the value of this <a class="crossref" href="../fixnum/intx.html">intx</a> as a <code>String</code> in the given radix.

<span class="param">radix</span> must be an integer between 2 and 16, inclusive.</p>
<div class="docs-inherited-from">docs inherited from <a href="../fixnum/intx.html">intx</a> </div></div>
<pre class="source">
String toRadixString(int radix) {
 if ((radix &lt;= 1) || (radix &gt; 16)) {
   throw "Bad radix: $radix";
 }
 int64 a = this;
 if (a.isZero()) {
   return "0";
 }
 if (a.isMinValue()) {
   return _minValues[radix];
 }

 String result = "";
 bool negative = false;
 if (a.isNegative()) {
   negative = true;
   a = -a;
 }

 int64 r = new int64._bits(radix, 0, 0);
 while (!a.isZero()) {
   a = _divMod(a, r, true);
   result = "${_hexDigit(_remainder._l)}$result";
 }
 return negative ? "-$result" : result;
}
</pre>
</div>
</div>
<div class="method"><h4 id="toString">
<button class="show-code">Code</button>
String <strong>toString</strong>() <a class="anchor-link" href="#toString"
              title="Permalink to int64.toString">#</a></h4>
<div class="doc">
<p>Returns the value of this <a class="crossref" href="../fixnum/int64.html#int64">int64</a> as a decimal <code>String</code>.</p>
<pre class="source">
String toString() {
 int64 a = this;
 if (a.isZero()) {
   return "0";
 }
 if (a.isMinValue()) {
   return "-9223372036854775808";
 }

 String result = "";
 bool negative = false;
 if (a.isNegative()) {
   negative = true;
   a = -a;
 }

 int64 ten = new int64._bits(10, 0, 0);
 while (!a.isZero()) {
   a = _divMod(a, ten, true);
   result = "${_remainder._l}$result";
 }
 if (negative) {
   result = "-$result";
 }
 return result;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          <div>This page was generated at 2013-03-06 14:07:29.438</div>
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
